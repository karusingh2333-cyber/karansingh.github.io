<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Avatar — Debug Safe</title>

  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Arial;color:#cfd9e6;background:#0b0c10}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:18px;gap:14px}
    .stage{
      width:min(920px,94vw);
      height:min(720px,72vh);
      min-height:400px;
      border-radius:14px;
      overflow:hidden;
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      display:block;
    }
    #canvas-container{width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:transparent}
    .fallback{
      color:#9fb8d6;
      text-align:center;
      padding:18px;
    }
    .below{max-width:920px;width:94vw;color:#cbdbe9;text-align:center;font-size:14px}
    a.btn{background:linear-gradient(90deg,#00b4ff,#3bd5ff);color:#001321;padding:8px 12px;border-radius:8px;text-decoration:none;font-weight:700}
    /* ensure canvas will show even if default body is white */
    canvas{display:block; width:100%!important; height:100%!important}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <div id="canvas-container" aria-hidden="true">
        <!-- canvas will be appended here -->
        <div class="fallback" id="fallbackMsg" style="display:none">
          WebGL not available or loading failed.<br>
          Try Chrome/Firefox on desktop, and check console for errors.
        </div>
      </div>
    </div>

    <div class="below">
      <div>Interactive avatar — move your cursor. If you see a blank page, open Console (F12) and check errors.</div>
      <div style="margin-top:10px"><a class="btn" href="projects.html">Open Projects</a></div>
    </div>
  </div>

  <!-- Use jsDelivr CDN for Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>

  <script>
  (function(){
    console.log('[safe-avatar] start');

    const container = document.getElementById('canvas-container');
    const fallback = document.getElementById('fallbackMsg');

    // WebGL availability check
    const testCanvas = document.createElement('canvas');
    const gl = testCanvas.getContext && (testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl'));
    if(!gl){
      console.error('[safe-avatar] WebGL not available');
      fallback.style.display = 'block';
      return;
    }

    // create renderer
    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      // safe color-space handling
      try {
        if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
        else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
      } catch(e){ console.warn('[safe-avatar] color-space assign failed', e); }
      container.appendChild(renderer.domElement);
    } catch (err) {
      console.error('[safe-avatar] renderer error', err);
      fallback.style.display = 'block';
      return;
    }

    // scene and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07060a);
    const camera = new THREE.PerspectiveCamera(30, 2, 0.1, 3000);
    camera.position.set(0, 0, 550); // safe initial position

    // lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(80, 120, 120);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x66ccff, 0.35);
    rim.position.set(-100, 80, 80);
    scene.add(rim);

    // root
    const root = new THREE.Group(); scene.add(root);

    // simple head
    const headGeom = new THREE.SphereGeometry(140, 40, 40);
    headGeom.scale(1, 1.02, 1);
    const skinMat = new THREE.MeshStandardMaterial({ color:0xffe1c7, roughness:0.52, metalness:0.02 });
    const head = new THREE.Mesh(headGeom, skinMat);
    head.position.set(0, -10, 0);
    root.add(head);

    // hair
    const hairGeom = new THREE.SphereGeometry(142, 32, 32, 0, Math.PI*2, 0, Math.PI*0.9);
    const hairMat = new THREE.MeshStandardMaterial({ color:0x0c2a46, roughness:0.45 });
    const hair = new THREE.Mesh(hairGeom, hairMat);
    hair.scale.set(1.02, 0.9, 1.02); hair.position.set(0, -40, 0);
    root.add(hair);

    // eyes (white spheres)
    const eyeWhite = new THREE.SphereGeometry(22, 24, 24);
    const eyeMat = new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.26 });
    const eyeL = new THREE.Mesh(eyeWhite, eyeMat); const eyeR = new THREE.Mesh(eyeWhite, eyeMat);
    eyeL.position.set(-60, 30, 100); eyeR.position.set(60, 30, 100);
    root.add(eyeL); root.add(eyeR);

    // pupil groups (for safe movement)
    const pupilGeom = new THREE.SphereGeometry(8, 18, 18);
    const pupilMat = new THREE.MeshStandardMaterial({ color:0x06121a });
    const gpL = new THREE.Group(); const gpR = new THREE.Group();
    gpL.position.copy(eyeL.position); gpR.position.copy(eyeR.position);
    root.add(gpL); root.add(gpR);
    const pupL = new THREE.Mesh(pupilGeom, pupilMat); const pupR = new THREE.Mesh(pupilGeom, pupilMat);
    pupL.position.set(0,0,22); pupR.position.set(0,0,22);
    gpL.add(pupL); gpR.add(pupR);

    // mouth
    const mouth = new THREE.Mesh(new THREE.TorusGeometry(32,3.0,8,40,Math.PI*0.68), new THREE.MeshStandardMaterial({ color:0x8a4f38 }));
    mouth.rotation.x = Math.PI*0.48; mouth.position.set(0,-30,95); root.add(mouth);

    // neck
    const neck = new THREE.Mesh(new THREE.CylinderGeometry(68,80,70,20), new THREE.MeshStandardMaterial({ color:0xffe1c7 }));
    neck.position.set(0,-140,0); root.add(neck);

    // renderer resize
    function resize(){
      const rect = container.getBoundingClientRect();
      const w = Math.max(100, Math.floor(rect.width));
      const h = Math.max(120, Math.floor(rect.height));
      renderer.setSize(w, h, false);
      camera.aspect = w / h; camera.updateProjectionMatrix();

      // responsive camera/scale
      if(w < 520){
        camera.position.set(0, 0, 620);
        root.scale.set(0.68,0.68,0.68);
      } else if(w < 820){
        camera.position.set(0, 0, 580);
        root.scale.set(0.82,0.82,0.82);
      } else if(w < 1080){
        camera.position.set(0, 0, 560);
        root.scale.set(0.92,0.92,0.92);
      } else {
        camera.position.set(0, 0, 550);
        root.scale.set(1,1,1);
      }
    }
    window.addEventListener('resize', resize, { passive:true });
    resize();

    // pointer logic
    let pointer = { x:null, y:null, active:false };
    function onPointer(e){
      pointer.active = true;
      pointer.x = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX) || pointer.x;
      pointer.y = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY) || pointer.y;
    }
    window.addEventListener('pointermove', onPointer, { passive:true });
    window.addEventListener('touchmove', onPointer, { passive:true });

    function getNorm(){
      const r = container.getBoundingClientRect();
      const cx = r.left + r.width/2, cy = r.top + r.height/2;
      const nx = ((pointer.x || cx) - cx) / (r.width/2);
      const ny = ((pointer.y || cy) - cy) / (r.height/2);
      return { nx: THREE.MathUtils.clamp(nx, -1, 1), ny: THREE.MathUtils.clamp(ny, -1, 1) };
    }

    // animate
    function animate(){
      const np = getNorm();
      // head rotation targets
      const targetY = np.nx * 0.18;
      const targetX = np.ny * -0.12;
      head.rotation.y += (targetY - head.rotation.y) * 0.07;
      head.rotation.x += (targetX - head.rotation.x) * 0.06;
      hair.rotation.y += (targetY - hair.rotation.y) * 0.05;
      root.rotation.y += (targetY * 0.03 - root.rotation.y) * 0.06;

      // pupils follow (offset)
      const maxPupil = 6.2;
      const px = np.nx * maxPupil * 1.3;
      const py = np.ny * -maxPupil * 0.9;
      gpL.position.x += ((eyeL.position.x + px) - gpL.position.x) * 0.18;
      gpL.position.y += ((eyeL.position.y + py) - gpL.position.y) * 0.12;
      gpR.position.x += ((eyeR.position.x + px) - gpR.position.x) * 0.18;
      gpR.position.y += ((eyeR.position.y + py) - gpR.position.y) * 0.12;

      // subtle float
      const t = performance.now() * 0.001;
      root.position.y = Math.sin(t * 0.8) * 0.6;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    console.log('[safe-avatar] ready — canvas appended', renderer.domElement);
    // show fallback only if no canvas exists (just safe-check)
    if(!renderer.domElement) fallback.style.display = 'block';

    // safety: reset pointer when leaving
    window.addEventListener('pointerleave', ()=>{ pointer.x = null; pointer.y = null; pointer.active=false; });

  })();
  </script>
</body>
</html>
