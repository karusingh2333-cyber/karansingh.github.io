<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive 3D Avatar — Portfolio</title>

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;500;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07060a;
      --muted:#cfd6df;
    }
    html,body{height:100%;margin:0;font-family:"Montserrat",system-ui,Arial}
    body{background:linear-gradient(180deg,#07060a 0%, #0d0d12 100%); color:var(--muted); -webkit-font-smoothing:antialiased;}
    .wrap{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
      box-sizing:border-box;
      gap:28px;
      flex-direction:column;
    }

    .stage{
      width:min(920px,92vw);
      height:min(760px,76vh);
      max-height:820px;
      border-radius:18px;
      overflow:hidden;
      position:relative;
      background: radial-gradient(600px 300px at 50% 10%, rgba(0,180,255,0.06), transparent 20%), linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
      box-shadow: 0 30px 80px rgba(3,7,18,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
      display:block;
    }

    /* overlay UI */
    .ui {
      position:absolute;
      left:20px;
      top:18px;
      z-index:4;
      color:#cfe7ff;
      font-weight:600;
      font-size:14px;
      pointer-events:none;
      display:flex;
      gap:12px;
      align-items:center;
    }
    .ui .email{opacity:0.85}
    .ui .nav{margin-left:auto; font-weight:500; opacity:0.9; pointer-events:auto;}
    .ui a{color:inherit;text-decoration:none;padding:6px 8px;border-radius:6px;background:transparent;opacity:0.85}

    /* caption */
    .caption{
      position:absolute;
      bottom:14px;
      left:50%;
      transform:translateX(-50%);
      z-index:4;
      color:rgba(255,255,255,0.7);
      font-size:13px;
      background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding:8px 12px;border-radius:999px;
      backdrop-filter: blur(6px);
    }

    /* responsive below */
    @media (max-width:720px){
      .stage{height:min(68vh,680px);}
      .ui{left:12px;top:12px; font-size:13px}
      .caption{font-size:12px}
    }

    /* helper for footer area below stage */
    .below{
      width:min(980px,94vw);
      display:flex;
      gap:20px;
      justify-content:space-between;
      align-items:center;
      color:var(--muted);
      font-size:14px;
      margin-top:18px;
    }
    .btn{
      background:linear-gradient(90deg,#00b4ff,#3bd5ff);
      color:#001321;padding:10px 14px;border-radius:10px;text-decoration:none;font-weight:700;
      box-shadow:0 14px 40px rgba(0,180,255,0.12)
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <div class="ui">
        <div class="email">example@mail.com</div>
        <div class="nav"><a href="index.html">HOME</a></div>
      </div>

      <!-- three.js canvas will be appended here by script -->
      <div id="canvas-container" style="width:100%;height:100%;"></div>

      <div class="caption">Move your cursor — the avatar follows your face & eyes</div>
    </div>

    <div class="below">
      <div>Selected Works — scroll down to see video embeds on the Projects page.</div>
      <div><a class="btn" href="projects.html">Open Projects</a></div>
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>
<script>
(function(){
  console.log('[avatar] init');

  // check for WebGL
  const webglCanvas = document.createElement('canvas');
  const gl = webglCanvas.getContext && (webglCanvas.getContext('webgl') || webglCanvas.getContext('experimental-webgl'));
  if(!gl){
    console.error('[avatar] WebGL not available in this browser');
    const fallback = document.createElement('div');
    fallback.style.cssText = "width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#aab8c6";
    fallback.innerHTML = '<div style="text-align:center">WebGL not supported.<br>Try Chrome/Firefox on desktop.</div>';
    document.getElementById('canvas-container').appendChild(fallback);
    return;
  }

  const container = document.getElementById('canvas-container');
  if(!container){
    console.error('[avatar] No canvas container found (#canvas-container)');
    return;
  }

  // create renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  // safe assignment for outputColorSpace / encoding across versions
  try{
    if('outputColorSpace' in renderer) {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else if('outputEncoding' in renderer && THREE.sRGBEncoding) {
      renderer.outputEncoding = THREE.sRGBEncoding;
    }
  }catch(e){ console.warn('[avatar] color-space assignment failed', e); }

  container.appendChild(renderer.domElement);

  // scene, camera
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x07060a);
  const camera = new THREE.PerspectiveCamera(28, 2, 0.1, 2000);
  camera.position.set(0, 0, 420);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.9);
  scene.add(hemi);
  const key = new THREE.DirectionalLight(0xffffff, 1.05);
  key.position.set(120, 200, 160);
  scene.add(key);
  scene.add(new THREE.AmbientLight(0x303040, 0.35));
  const rim = new THREE.DirectionalLight(0x66ccff, 0.45);
  rim.position.set(-200,120,100);
  scene.add(rim);

  // root group
  const root = new THREE.Group();
  scene.add(root);

  // safe helpers to build geometry (same as earlier)
  const headGeom = new THREE.SphereGeometry(140, 48, 48);
  headGeom.scale(1, 1.02, 1);
  const skinMat = new THREE.MeshStandardMaterial({ color: 0xffe1c7, metalness:0.02, roughness:0.48, clearcoat:0.08, clearcoatRoughness:0.25 });
  const head = new THREE.Mesh(headGeom, skinMat);
  head.position.set(0,-10,0);
  root.add(head);

  const hairGeom = new THREE.SphereGeometry(142, 36, 36, 0, Math.PI*2, 0, Math.PI*0.9);
  const hairMat = new THREE.MeshStandardMaterial({ color:0x0c2945, metalness:0.02, roughness:0.45 });
  const hair = new THREE.Mesh(hairGeom, hairMat);
  hair.scale.set(1.02,0.9,1.02);
  hair.position.set(0,-40,0);
  root.add(hair);

  const earGeom = new THREE.SphereGeometry(18, 24, 24);
  const earLeft = new THREE.Mesh(earGeom, skinMat);
  earLeft.position.set(-150, -10, 10);
  earLeft.scale.set(1,0.9,0.7);
  root.add(earLeft);
  const earRight = earLeft.clone();
  earRight.position.set(150, -10, 10);
  root.add(earRight);

  const eyeWhiteGeom = new THREE.SphereGeometry(22, 28, 28);
  const eyeWhiteMat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0, roughness:0.32 });
  const eyeLeft = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
  const eyeRight = eyeLeft.clone();
  eyeLeft.position.set(-60,30,100);
  eyeRight.position.set(60,30,100);
  root.add(eyeLeft); root.add(eyeRight);

  const pupilGeom = new THREE.SphereGeometry(8.5, 20, 20);
  const pupilMat = new THREE.MeshStandardMaterial({ color:0x06121a, metalness:0, roughness:0.3 });
  const leftGroup = new THREE.Group(), rightGroup = new THREE.Group();
  leftGroup.position.copy(eyeLeft.position); rightGroup.position.copy(eyeRight.position);
  root.add(leftGroup); root.add(rightGroup);
  const pupilLeft = new THREE.Mesh(pupilGeom, pupilMat);
  const pupilRight = new THREE.Mesh(pupilGeom, pupilMat);
  pupilLeft.position.set(0,0,22); pupilRight.position.set(0,0,22);
  leftGroup.add(pupilLeft); rightGroup.add(pupilRight);

  const mouth = new THREE.Mesh(new THREE.TorusGeometry(32,3.2,8,40,Math.PI*0.68), new THREE.MeshStandardMaterial({ color:0x8a4f38, roughness:0.72 }));
  mouth.rotation.x = Math.PI*0.48; mouth.position.set(0,-30,95); root.add(mouth);

  const neck = new THREE.Mesh(new THREE.CylinderGeometry(68,80,70,28), new THREE.MeshStandardMaterial({ color:0xffe1c7, roughness:0.55 }));
  neck.position.set(0,-140,0); root.add(neck);

  // rim
  const rimGeo = new THREE.CircleGeometry(260,64);
  const rimMat = new THREE.MeshBasicMaterial({ color:0x0bbcff, transparent:true, opacity:0.06 });
  const rimMesh = new THREE.Mesh(rimGeo, rimMat);
  rimMesh.position.set(0,-60,-260); rimMesh.rotation.x = -0.15; scene.add(rimMesh);

  // resizing logic
  function resize(){
    const rect = container.getBoundingClientRect();
    const w = Math.max(20, Math.floor(rect.width));
    const h = Math.max(20, Math.floor(rect.height));
    renderer.setSize(w, h, false);
    camera.aspect = w / h; camera.updateProjectionMatrix();

    if(w < 520){
      camera.position.set(0,0,360); root.scale.set(0.85,0.85,0.85);
    } else if(w < 820){
      camera.position.set(0,0,400); root.scale.set(0.95,0.95,0.95);
    } else { camera.position.set(0,0,420); root.scale.set(1,1,1); }
  }
  window.addEventListener('resize', resize, { passive:true });
  // initial call
  resize();

  // pointer tracking
  let pointer = {x:0,y:0, active:false};
  function onPointerMove(e){
    pointer.active = true;
    pointer.x = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX) || pointer.x;
    pointer.y = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY) || pointer.y;
  }
  window.addEventListener('pointermove', onPointerMove, {passive:true});
  window.addEventListener('touchmove', onPointerMove, {passive:true});

  function getNorm(){
    const r = container.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const nx = ((pointer.x || cx) - cx) / (r.width/2);
    const ny = ((pointer.y || cy) - cy) / (r.height/2);
    return { nx: THREE.MathUtils.clamp(nx, -1,1), ny: THREE.MathUtils.clamp(ny,-1,1) };
  }

  // animate loop
  const clock = new THREE.Clock();
  function animate(){
    const np = getNorm();
    const targetY = np.nx * 0.18;
    const targetX = np.ny * -0.12;
    head.rotation.y += (targetY - head.rotation.y) * 0.08;
    head.rotation.x += (targetX - head.rotation.x) * 0.06;
    hair.rotation.y += (targetY - hair.rotation.y) * 0.06;
    root.rotation.y += (targetY * 0.04 - root.rotation.y) * 0.06;

    const maxPupil = 6.8;
    const px = np.nx * maxPupil * 1.3;
    const py = np.ny * -maxPupil * 0.9;
    leftGroup.position.x += ((eyeLeft.position.x + px) - leftGroup.position.x) * 0.18;
    leftGroup.position.y += ((eyeLeft.position.y + py) - leftGroup.position.y) * 0.12;
    rightGroup.position.x += ((eyeRight.position.x + px) - rightGroup.position.x) * 0.18;
    rightGroup.position.y += ((eyeRight.position.y + py) - rightGroup.position.y) * 0.12;

    const t = performance.now() * 0.0012;
    root.position.y += Math.sin(t) * 0.06;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  console.log('[avatar] ready');

  // reset on leave
  window.addEventListener('pointerleave', ()=>{ pointer.x = container.getBoundingClientRect().left + container.clientWidth/2; pointer.y = container.getBoundingClientRect().top + container.clientHeight/2; pointer.active=false; });

})();
</script>

</body>
</html>
